/*

iRead II for Prizm Pro
Browser library source file

(c)2013 ExAcler & wtof1996 Some rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "fxchslib.h"
#include "string_e.h"
#include "browser.h"

const char Menu_Main[]=
{0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,
0xFF,0xF7,0xFF,0xFF,0xFF,0xEF,0xFF,0xF9,0xFF,0xFB,0xEF,0xFF,0xFF,0xFF,0xFF,0xF0,
0xFF,0xFB,0x0,0xFF,0xEF,0xEF,0xFF,0xF9,0xFF,0xFD,0xE7,0xFF,0xE0,0x1,0xFF,0xF0,
0xFF,0xEB,0xFE,0xFF,0xF3,0x0,0xFF,0xF9,0xFF,0xFC,0xEF,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEE,0xF6,0xFF,0xF7,0xEF,0xFF,0xF9,0xFF,0xFD,0xDB,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEF,0x6E,0xFF,0xFE,0x0,0x7F,0xF9,0xFF,0xC0,0x1,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEC,0x6,0xFF,0xFF,0xBE,0xFF,0xF9,0xFF,0xFF,0x7F,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xED,0xF6,0xFF,0xC6,0xD5,0xFF,0xF9,0xFF,0xFF,0x7F,0xFF,0x80,0x0,0xFF,0xF0,
0xFF,0xED,0xF6,0xFF,0xF7,0x57,0xFF,0xF9,0xFF,0xFF,0x7F,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEC,0x6,0xFF,0xF7,0x77,0xFF,0xF9,0xFF,0x80,0x0,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEF,0x5E,0xFF,0xF6,0x0,0x7F,0xF9,0xFF,0xFF,0x7F,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEF,0x5A,0xFF,0xF7,0xF7,0xFF,0xF9,0xFF,0xFE,0xBF,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEE,0xDA,0xFF,0xF7,0xEB,0xFF,0xF9,0xFF,0xFD,0xDF,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xE9,0xE2,0xFF,0xF5,0xDD,0xFF,0xF9,0xFF,0xFB,0xEF,0xFF,0xFF,0x7F,0xFF,0xF0,
0xFF,0xEF,0xFE,0xFF,0xF3,0xBE,0xFF,0xF1,0xFF,0xF7,0xE7,0xFF,0xFB,0x7F,0xFF,0xE0,
0xFF,0xEF,0xFA,0xFF,0xF7,0x7E,0x7F,0xE1,0xFF,0xEF,0xF1,0xFF,0xFD,0x7F,0xFF,0xC0,
0xFF,0xEF,0xFD,0xFF,0xFE,0xFE,0xFF,0xC1,0xFF,0xDF,0xFB,0xFF,0xFE,0xFF,0xFF,0x80,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x81,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x0,
0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x0,};

char* fList[100];    //  文件列表数组

int getn(char* a[])
{
    /*
	    获取二维数组的有效项目数
        参数说明：
	        a[]: 欲获取项数的二维数组
		返回值：
		    有效项目数 (不为 0)
    */

    int i;
	for (i=0;a[i];++i);
	return i;
}

static int fstrlen(const FONTCHARACTER* a)
{
    /*
	    获取 FONTCHARACTER 类型的字符长度
        参数说明：
	        a: 欲获取字符长度的 FONTCHARACTER 类型
		返回值：
		    有效长度
    */
    int i;
	for (i=0;a[i];++i);
	return i;
}

static char* font_to_char(const FONTCHARACTER* ffname,char* cfname)
{
    /*
	    将 FONTCHARACTER 类型转换为字符串
        参数说明：
	        ffname: 欲转换的 FONTCHARACTER 类型
			cfname: 输出的字符串
		返回值：
		    输出的字符串
    */
    int i,len=fstrlen(ffname);

	for(i=0;i<len;++i)
		cfname[i]=ffname[i];

	cfname[i]=0;
	return cfname;
}

char** get_file_list(const char* path)
{
    /*
	    获取指定目录下的文件列表
        参数说明：
	        path: 指定的目录
    */
    int handle;
	FILE_INFO fInfo;    //  文件类型信息结构
    FONTCHARACTER fpath[64],fnfile[64];
	char nfile[64];
	int i=0;
	
	char_to_font(path,fpath);
	if (Bfile_FindFirst(fpath,&handle,fnfile,&fInfo)!=0)    //  如果当前目录下无文件，跳出
	    return 0;
	
	font_to_char(fnfile,nfile);
	if ((strstr(nfile,"txt"))||(fInfo.type==DT_DIRECTORY))    //  如果找到 txt 文件或文件夹
	{
	    if (!fList[0]) 
		    fList[0]=(char*)malloc(64);
		fList[0][0]='\0';
	    if (fInfo.type==DT_DIRECTORY)
		    strcat(fList[0],"[");
	    strcat(fList[0],nfile);    //  加入字符串
		fList[0][strlen(fList[0])]='\0';
	}
	else i=-1;
	
	while (Bfile_FindNext(handle,fnfile,&fInfo)==0)
	{
	    font_to_char(fnfile,nfile);
		if ((strstr(nfile,"txt"))||(fInfo.type==DT_DIRECTORY))
	    {
		    ++i;
		    if (!fList[i]) 
		        fList[i]=(char*)malloc(64);
			fList[i][0]='\0';
	        if (fInfo.type==DT_DIRECTORY)
		        strcat(fList[i],"[");
	        strcat(fList[i],nfile);    //  加入字符串
			fList[i][strlen(fList[i])]='\0';
	    }
	}
	fList[i+1]=0;
	
	Bfile_FindClose(handle);
	
	if (i!=-1)
	    return fList;
	else
	    return 0;
}

void draw_browser(const char* path,int firstf,int selp,char** a)
{
    /*
	    文件浏览器 (绘制)
    */
    int i=firstf;
	int start=49+24*selp;
	char* pathcat=(char*)malloc(strlen(path)+8);
	char* tmp;
	
	strcpy(pathcat,path);
	strcat(pathcat,"\\*");
	
	Bdisp_AllClr_VRAM();
	
	print_chs_2(0,24,0x001F,"文本文档列表");
	locate_OS(12,1);
	Print_OS("[        ]",0,0);
	
	if (!strcmp(path,"\\\\fls0"))
		print_chs_2(216,24,0,"根目录");
	else
	{
	    tmp=(char*)malloc(64);
		strcpy(tmp,strrchr(path,'\\'));
		tmp[strlen(tmp)]='\0';
		locate_OS(13,1);
	    Print_OS(++tmp,0,0);
	}
	
	if (a)
	{
	    while (a[i++])
	    {
	        if (i>firstf+6) break;
		    locate_OS(2,i-firstf+1);
			Print_OS(a[i-1],0,0);
			if (strchr(a[i-1],'['))
			{
			    locate_OS(2+strlen(a[i-1]),i-firstf+1);
			    Print_OS("]",0,0);
		    }
		}
	}
	
	if (a)
	{
	    if (firstf>0)
	    {
	        locate_OS(21,2);
	        Print_OS("\xe6\x92",0,0);
	    }
	    if (firstf+6<getn(a))
	    {
	        locate_OS(21,7);
	        Print_OS("\xe6\x93",0,0);
	    }
	    Bdisp_AreaReverseVRAM(0,start,384,start+22);
	}
	else
		print_chs_2(75,101,0,"无文档");
	
	draw_pic(0,192,124,22,0,Menu_Main);
	
	free(pathcat);
}

int print_chs_2(int x,int y,int color,const unsigned char* str)
{
    /*
	    绘制字符串，注释详见 divide_page 函数
	*/

    int cx=x;
    int cy=y;
    int i=0;
    const int pp=18;
	int is_chs=0;
    char temp[50];
    for (;str[i];)
    {
        is_chs=str[i] & 0x80;
        if ((cx+pp)>384)
            goto cn;
        if (is_chs)
        {
            print_chs_char(cx,cy,color,str[i],str[i+1]);
            i+=2;
        }
        else
        {
            print_asc_char (cx,cy,0,str[i]);
			i++;
        }
        
		if (is_chs)
            cx+=25;
		else
		    cx+=16;
        
        if (cx>384)
        {
        cn:
            cx=x;
			cy+=25;
        }
    }
}